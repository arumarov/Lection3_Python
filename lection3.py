# АНОНИМНЫЕ, LAMBDA ФУНКЦИИ
# def f(x):
#     return x**2

# # print(type(f)) ## проверяем тип функции
# # ## <class 'function'> # результат

# g = f # передаем переменной g значение функции f
# print(f(4)) # вызываем функцию f, передавая в нее аргументы
# print(g(4)) # вызываем переменную g, передавая в нее аргументы, результат будет одинаковый
# # Теперь у нас есть переменная g, которая хранит в себе ссылку на функцию

# ##########
# def calc1(x):
#     return x+10

# print(calc1(10))

# def calc2(x):
#     return x*10

# print(calc2(10))

# def math(op, x):
#     print(op(x))

# math(calc2, 10) # в качестве первого аргумента указываем функцию calc2
# math(calc1, 10)

# ##########
# def sum(x, y):
#     return x + y

# sum = lambda q, w: q + w +1 # то же, что и в функции sum, описанной выше

# def mylt(x, y):
#     return x*y

# def calc(op, a, b):
#     print(op(a, b))
#     return op(a, b)

# calc(mylt, 4, 5)
# calc(sum, 4, 5)
# calc(lambda q, w: q + w +1, 4, 5) # сразу указываем lambda

# ##########
# Задача
# В файле хранятся числа, нужно выбрать четные и составить список пар (число; квадрат числа). 
# Пример:
# 1 2 3 5 8 15 23 38
# Получить:
# [(2, 4), (8, 64), (38, 1444)]
# Мое решение
# list = [1, 2, 3, 5, 8, 15, 23, 38]
# list1 = [(list[i], list[i]**2) for i in (1, (len(list)-1)) if list[i]%2 == 0]
# print(list1)

# Решение с лекции
# f = open('file.txt', 'r') # открываем файл
# data = f.read() + ' '
# f.close # закрываем файл

# numbers = [] #создаем новый список

# while data != '': # пока строка не пустая
#     space_pos = data.index(' ') # находим первую позицию пробела
#     numbers.append(int(data[:space_pos])) # взять то, что находится от первого символа до позиции первого пробела, 
#     # превратить в число и добавить в список номеров
#     data = data[space_pos+1:] # обновить строку с учетом того, что уже использовали

# out = [] # создаем новый список
# for e in numbers: # пробегаемся по исходному списку
#     if not e % 2: # если является четным числом
#         out.append((e, e ** 2)) # добавляем в новый список кортежи
# print(out)
# [(2, 4), (8, 64), (38, 1444)]  # результат

# ##########
# Можно ли сделать лучше данный код?
# Используем lambda, list comprehension
# def select(f, col):
#     return [f(x) for x in col]

# def where(f, col):
#     return [x for x in col if f(x)]

# data = '1 2 3 5 8 15 23 38'.split() ## возвращает набор строк

# res = select(int, data) # вызываем функцию select
# res = where(lambda x: not x%2, res) # вызываем функцию where, используя lambda
# res = select(lambda x: (x, x**2), res)
# print(res)

# ##########
# Используем lambda, list comprehension, map
# def where(f, col):
#     return [x for x in col if f(x)]

# data = '1 2 3 5 8 15 23 38'.split() ## возвращает набор строк

# res = map(int, data) # вызываем функцию map
# res = where(lambda x: not x%2, res) # вызываем функцию where, используя lambda
# res = list(map(lambda x: (x, x**2), res)) # вызываем функцию map
# print(res)

# ##########
# Используем lambda, list comprehension, map, filter
# data = '1 2 3 5 8 15 23 38'.split() ## возвращает набор строк

# res = map(int, data) # вызываем функцию map
# res = filter(lambda x: not x%2, res) # вызываем функцию filter
# res = list(map(lambda x: (x, x**2), res)) # вызываем функцию map
# print(res)

###########
###########
###########

# # LIST COMPREHENSION
# # [exp for item in iterable] # exp - некое выражение, iterable - итерируемый объект
# # [exp for item in iterable (if conditional)] # через if прописываем условие
# # [exp <if conditional> for item in iterable (if conditional)]
# list = []

# for i in range(1, 101): 
#     if(i%2 == 0):
#         list.append(i)

# print(list) # вывод на печать списка
# # Можно ли создать список более красиво?

# list = [i for i in range(1,21)] # краткое создание списка
# print(list)

# list = [i for i in range(1,21) if i%2 == 0] # прописываем условие
# print(list)

# list = [(i, i) for i in range(1,21) if i%2 == 0] #создаем список кортежей
# print(list)

# def f(x):
#     return x**3

# list = [f(i) for i in range(1,21) if i%2 == 0] # при создании списка используем функцию f
# print(list)

# list = [(i, f(i)) for i in range(1,21) if i%2 == 0] # создаем список кортежей, используя функцию f
# print(list)

###########
###########
###########

# # MAP
# # Функция map() применяет указанную функцию к каждому элементу итерируемого объекта и возвращает итератор с новыми объектами.

# ##########
# li = [x for x in range(1,20)]

# li = list(map(lambda x: x+10, li)) #вызываем map(преобразовывая в список) - первый аргумент - lambda, второй аргумент - набор данных

# print(li)
# # [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29] # результат - к каждому элементу применяется функция li

# ##########
# data = list(map(int, input().split())) # получаем набор данных от пользователя, разбиваем его(через пробелы), вызываем map, первый аргумент - int
# print(data)
# # 1 56 999 482 58 # вводим с клавиатуры
# # [1, 56, 999, 482, 58] # результат - список с введенными данными в формате int

# # Технически можно не выполнять преобразование к типу list
# data = map(int, input().split())

# for e in data:
#     print(e)

# #56 99 82 # вводим с клавиатуры
# #56 # результат - введенные данные в формате int
# #99
# #82
# ##########

# data = map(int, '1 2 3'.split())

# for e in data:
#     print(e)

# print('--')

# for e in data: # запуская map во второй раз, мы не получаем значений
#     print(e)
# # Нельзя пройтись дважды, но если на основе map сделаем отдельный список, и с ним будем работать


###########
###########
###########

# #FILTER
# # Функция filter() применяет указанную функцию к каждому элементу итерируемого объекта 
# # и возвращает итератор с теми объектами, для которых функция вернула True

# data = [x for x in range(10)]

# res = list(filter(lambda x: not x%2, data)) #вызываем функцию filter, где в качестве первого аргумента - lambda
# print(res)
# [0, 2, 4, 6, 8] # результат - функция filter фильтрует данные и вносит в список только четные элементы

###########
###########
###########
# #ZIP
# # Функция zip() применяется к набору итерируемых объектов и возвращает итератор с кортежами из элементов входных данных
# # Количество элементов в результате равно минимальному количеству элементов входного набора

# zip ([1, 2, 3], [ 'о', 'д', 'т'], ['f','s','t'])
# # первый элемент первого набора + первый элемент второго набора и т.д => преобразование в кортеж, и т.д.
# [(1, 'о', 'f'), (2, 'д', 's'), (3, 'т', 't')] 
# print(zip)

# users = ['user1', 'user2', 'user3', 'user4', 'user5']
# ids = [4, 5, 9, 14, 7]
# salary = [111, 222, 333]

# data = list(zip(users, ids, salary)) # вызываем zip
# print(data)
# [('user1', 4), ('user2', 5), ('user3', 9), ('user4', 14), ('user5', 7)] # результат - список кортежей
# # функция zip пробегается по минимальному входящему набору


###########
###########
###########
# #ENUMERATE
# # - Функция enumerate() применяется к итерируемому объекту и 
# # возвращает новый итератор с кортежами из индекса и элементов входных данных
# enumerate(['Казань', 'Смоленск', 'Рыбки', 'Чикаго']) # на вход принимает набор данных

# [(0, 'Казань'), (1, 'Смоленск'), (2, 'Рыбки'), (3, 'Чикаго')] # на выходе - кортежи с явно пронумерованными элементами
# users = ['user1', 'user2', 'user3', 'user4', 'user5']
# ids = [4, 5, 9, 14, 7]
# salary = [111, 222, 333]

# data = list(enumerate(users))
# print(data)
# # [(0, 'user1'), (1, 'user2'), (2, 'user3'), (3, 'user4'), (4, 'user5')] # результат - список кортежей